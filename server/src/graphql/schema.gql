# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type LogoutResponse {
  loggedOut: Boolean!
}

type User {
  id: String!
  name: String!
  email: String!
  password: String!
}

type NewTokensResponse {
  accessToken: String!
  refreshToken: String!
  user: User!
}

type SignResponse {
  accessToken: String!
  refreshToken: String!
  user: User!
}

type WeeklyPoints {
  points: Int!
  pointsAverage: Float!
}

type Habit {
  id: String!
  name: String!
  dueDate: DateTime
  isPaused: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type HabitTrackingAvgAggregate {
  points: Float
}

type HabitTrackingSumAggregate {
  points: Int
}

type HabitTrackingAggregate {
  _sum: HabitTrackingSumAggregate
  _avg: HabitTrackingAvgAggregate
}

type HabitTracking {
  id: String!
  date: DateTime!
  points: Int!
  habitId: Habit!
  userId: User!
}

type TasksComplexity {
  id: String!
  name: String!
  points: Int
}

type Task {
  id: String!
  title: String!
  status: String!
  dueDate: DateTime
  points: Int
  userId: User!
  complexId: TasksComplexity!
  completedDate: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Query {
  habits(isPaused: Boolean, dueDate: DateTime): [Habit!]!
  habit(id: String!): Habit!
  habitTrackings(dateStart: DateTime, dateEnd: DateTime): [HabitTracking!]!
  habitTracking(id: Float!): HabitTracking
  habitTrackingsAggregate(dateStart: DateTime, dateEnd: DateTime): HabitTrackingAggregate
  user(where: UserWhereUniqueInput): User!
  tasks(where: TaskWhereInput, orderBy: [TaskOrderByWithRelationInput!], cursor: TaskWhereUniqueInput, take: Float, skip: Float): [Task!]!
  task(where: TaskWhereUniqueInput): Task!
  taskComplexities: [TasksComplexity!]!
  getWeeklyPoints(dateStart: DateTime!, dateEnd: DateTime!): WeeklyPoints!
}

input UserWhereUniqueInput {
  id: String
}

input TaskWhereInput {
  id: StringFilter
  title: StringFilter
  complexId: IntFilter
  userId: StringFilter
  status: StringFilter
  points: IntFilter
  dueDate: DateTimeFilter
  completedDate: DateTimeFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  complexity: TasksComplexitiesRelationFilter
  AND: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  NOT: [TaskWhereInput!]
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: String
  mode: QueryMode
}

enum QueryMode {
  default
  insensitive
}

input IntFilter {
  equals: Float
  lt: Float
  lte: Float
  gt: Float
  gte: Float
}

input DateTimeFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
}

input TasksComplexitiesRelationFilter {
  is: TasksComplexitiesWhereInput
  isNot: TasksComplexitiesWhereInput
}

input TasksComplexitiesWhereInput {
  id: IntFilter
  points: IntFilter
  name: StringFilter
  AND: [TasksComplexitiesWhereInput!]
  OR: [TasksComplexitiesWhereInput!]
  NOT: [TasksComplexitiesWhereInput!]
}

input TaskOrderByWithRelationInput {
  id: SortOrder
  title: SortOrder
  points: SortOrder
  dueDate: SortOrder
  status: SortOrder
  completedDate: SortOrder
  createdAt: SortOrder
  complexity: TasksComplexitiesOrderByWithRelationInput
}

enum SortOrder {
  asc
  desc
}

input TasksComplexitiesOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  points: SortOrder
}

input TaskWhereUniqueInput {
  id: String
}

type Mutation {
  createHabit(createHabitInput: CreateHabitInput!): Habit!
  updateHabit(updateHabitInput: UpdateHabitInput!): Habit!
  deleteHabit(deleteHabitInput: DeleteHabitInput!): Habit!
  deleteHabits(deleteHabitsInput: DeleteHabitsInput!): Float!
  createHabitTracking(createHabitTrackingInput: CreateHabitTrackingInput!): HabitTracking!
  updateHabitTracking(updateHabitTrackingInput: UpdateHabitTrackingInput!): HabitTracking!
  deleteHabitTracking(deleteHabitTracking: DeleteHabitTrackingInput!): HabitTracking
  createUser(createUserInput: CreateUserInput!): User!
  createTask(createTaskInput: CreateTaskInput!): Task!
  updateTask(updateTaskInput: UpdateTaskInput!): Task!
  deleteTask(where: TaskWhereUniqueInput): Task!
  signup(signupInput: SignupInput!): SignResponse!
  signin(signinInput: SigninInput!): SignResponse!
  logout(id: String!): LogoutResponse!
  newTokens: NewTokensResponse!
}

input CreateHabitInput {
  """Name of habit"""
  name: String!
  dueDate: DateTime

  """If habit is paused it doesnt list as active habit"""
  isPaused: Boolean!
}

input UpdateHabitInput {
  name: String
  dueDate: DateTime
  isPaused: Boolean
  id: String!
}

input DeleteHabitInput {
  id: String!
}

input DeleteHabitsInput {
  ids: [String!]!
}

input CreateHabitTrackingInput {
  date: DateTime
  points: Int!
  habitId: String!
}

input UpdateHabitTrackingInput {
  date: DateTime
  points: Boolean
  habitId: String
  id: String!
  userId: DateTime
}

input DeleteHabitTrackingInput {
  date: DateTime!
  habitId: String!
}

input CreateUserInput {
  name: String!
  email: String!
  password: String!
}

input CreateTaskInput {
  title: String!
  points: Int
  status: String! = "todo"
  dueDate: DateTime
  complexId: Int!
  completedDate: DateTime
}

input UpdateTaskInput {
  title: String
  points: Int
  status: String = "todo"
  dueDate: DateTime
  complexId: Int
  completedDate: DateTime
  id: String!
}

input SignupInput {
  name: String!
  email: String!
  password: String!
}

input SigninInput {
  email: String!
  password: String!
}